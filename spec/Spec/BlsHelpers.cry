/**
 * The module contains functions that perform BLS operations.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#bls12-381-helpers
 */
module Spec::BlsHelpers where

import Common::Utils
import Spec::BlsEC

/**
 * BLS field elements are 256-bits long.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#custom-types
 */
type BlsFieldSize = 256
type BlsFieldElement = [BlsFieldSize]

/**
 * Specified by the consensus-specs.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#constants
 */
BLS_MODULUS : BlsFieldElement
BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513

/**
 * Compute the modular inverse of x
 *  i.e. return y such that x * y % BLS_MODULUS == 1
 * Precondition: x != 0 BLS_MODULUS
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#bls_modular_inverse
 * NOTE: Cryptol can not perform exponentiation with negative exponents,
 *  we cannot just execute `x^^(-1) % BLS_MODULUS` like the Python spec does.
 */
bls_modular_inverse : BlsFieldElement -> BlsFieldElement
bls_modular_inverse x = fromInteger (modular_inverse x' modulus) where
    x' = toInteger x
    modulus = toInteger BLS_MODULUS

/**
 * Divide two field elements: x by y
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#div
 */
bls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement
bls_div x y = fromInteger (div_mod x' y' modulus) where
    x' = toInteger x
    y' = toInteger y
    modulus = toInteger BLS_MODULUS

/**
 * Return x to power of [0, n-1].
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_powers
 * NOTE: this Cryptol function requires n >= 1, which is not the same constraint on the Python function,
 *  whose constraint is n >= 0.
 */
compute_powers : {n} (fin n, width n <= 64, n >= 2) => BlsFieldElement -> [n]BlsFieldElement
compute_powers x = powers where
        powers = [x] # [(powers@(i-1) * x) % BLS_MODULUS | i <- [1 .. n-1]]

/**
 * Performs a multi-scalar multiplication between G1 `points` and `scalars`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#multi_exp
 */
g1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt64 -> G1Point
g1_multi_exp points scalars = results!0 where
    results = [G1_INFINITY] # [g1_add (results@i) (g1_multi (points@i) (scalars@i)) | i <- [0 .. len-1]]

/**
 * Helper function for decompressing a G1 or G2 compresed point.
 *
 * The most-significant three bits of a G1 or G2 encoding should be masked away before
 * the coordinate(s) are interpreted.
 * These bits are used to unambiguously represent the underlying element.
 * The format: (cFlag, bFlag, aFlag, x)
 *  - cFlag: is '1' to indicated a compressed point, '0' otherwise.
 *  - bFlag: is '1' to indicate a point at infinity, '0' otherwise.
 *     - NOTE: the cFlag must also be set to indicate an intentionally
 *             compressed infinity point.
 *  - aFlag: is used to store the most significant bit of the y-coordinate.
 *  - x: is the x-coordinate of the point.
 *
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls/point_compression.py#L43
 *
 * ```repl
 * :prove get_flags`{8} 0xC0 == (True, True, False)
 * :prove get_flags`{384} (0xE0 # (zero:[384-8])) == (True, True, True)
 * ```
 */
get_flags : {n} (fin n, n >= 3) => [n] -> (Bit, Bit, Bit)
get_flags z = (c_flag, b_flag, a_flag) where
    c_flag = int_to_bit`{n} ((z >> (`n - 1)) && 1)  // The most significant bit
    b_flag = int_to_bit`{n} ((z >> (`n - 2)) && 1)  // The second-most significant bit
    a_flag = int_to_bit`{n} ((z >> (`n - 3)) && 1)  // The third-most significant bit

/**
 * Decompress the G1 compressed point
 *
 * Recovers x and y coordinates from the compressed point.
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls/point_compression.py#L80
 */
decompress_G1 : Bytes48 -> (Integer, Integer)
decompress_G1 z =
    // cFlag == 1 indicates the compressed form
    // MSB should be 1
    if ~cFlag then
        error "decompress_G1: cFlag must be 1"
    else if bFlag then
        // 3 MSBs should be b110
        if aFlag then
            error "decompress_G1: a point at infinity should have aFlag == 0"
        else (0, 0)
    // Else, not point at infinity
    // 3 MSBs should be b100 or b101
    else if x >= q then
        error "decompress_G1: point value should be less than field modulus"
    else if (y^^2 % q) != (x^^3 + b) % q then
        error "The given point is not on G1: y^^2 = x^^3 + 4"
    // Choose the y whose leftmost bit is equal to the aFlag
    else if ((y * 2) / q) != (bit_to_integer aFlag) then
        (x, y')
    else
        (x, y)
    where
        (cFlag, bFlag, aFlag) = get_flags z
        x = (toInteger z) % (2^^381)
        q = toInteger Fp
        b = 4 // Our elliptic curve equation is y^^2 = x^^3 + 4
        // Try solving y coordinate from the equation y^^2 = x^^3 + b using quadratic residue
        y = pow_mod`{FP} base exp
        base = (x^^3 + b) % q
        exp = ((q + 1) / 4 ) % q
        y' = q - y

/**
 * Compressed G1 point at infinity
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#constants
 */
G1_POINT_AT_INFINITY : Bytes48
G1_POINT_AT_INFINITY = 0xc0 # (zero:[47*BYTE_WIDTH])

/**
 * Deserialize the G1 bytes into a G1 point
 */
bytes48_to_g1_point : Bytes48 -> G1Point
bytes48_to_g1_point bytes = { xCoord = fromInteger x, yCoord = fromInteger y} where
    (x, y) = decompress_G1 bytes

/*
 * ===============
 * Unit test suite
 * ===============
 */

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_bls_modular_inverse 1 1
 * :prove test_bls_modular_inverse 2 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001
 * :prove test_bls_modular_inverse 3 0x4d491a377113a8daccd13ab0066be558e27e6d5755543d54aaaaaaaa00000001
 * ```
 * NOTE: we just chose the values at "random." Checked against: https://planetcalc.com/3298/.
 */
test_bls_modular_inverse : BlsFieldElement -> BlsFieldElement -> Bit
property test_bls_modular_inverse x expectedY =
    bls_modular_inverse x == expectedY

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_bls_div 1 2 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001
 * :prove test_bls_div 13 1 13
 * :prove test_bls_div 57 13 0x1ac0b075a72457fcf8210a7802390a776218122813b0da27276276272762762c
 * ```
 * NOTE: we just chose the last value at "random"
 */
test_bls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement -> Bit
property test_bls_div x y expected =
    bls_div x y == expected

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_compute_powers`{2} 13 [13, 13^^2]
 * :prove test_compute_powers`{5} 13 [13, 13^^2, 13^^3, 13^^4, 13^^5]
 * ```
 * NOTE: we just chose these values at "random"
 */
test_compute_powers : {n} (fin n, width n <= 64, n >= 2) => BlsFieldElement -> [n]BlsFieldElement -> Bit
property test_compute_powers x expected =
    join (compute_powers`{n} x) == join expected

/**
 * Unit tests for `g1_multi_exp`.
 * ```repl
 * :prove test_g1_multi_exp`{1} [G1] [1] G1
 * :prove test_g1_multi_exp`{2} [G1, G1] [2, 3] G1_5P
 * :prove test_g1_multi_exp`{2} [G1_3P, G1_2P] [1, 2] G1_7P
 * :prove test_g1_multi_exp`{3} [G1_4P, G1_2P, G1_3P] [2, 3, 5] (g1_multi_exp`{2} [G1_5P, G1_7P] [3, 2])
 * ```
 */
test_g1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt64 -> G1Point -> Bit
property test_g1_multi_exp points scalars expected =
    g1_point_eq (g1_multi_exp points scalars) expected

/**
 * Test point for the decompression function `bytes48_to_g1_point`
 */
G1_INVALID_INFINITY_COMPRESSED : Bytes48
G1_INVALID_INFINITY_COMPRESSED = cFlag + bFlag + aFlag where
    cFlag = (1 << 383) // is compressed
    bFlag = (1 << 382) // is infinity
    aFlag = (1 << 381) // invalid aFlag when infinity

/**
 * Test point for the decompression function `bytes48_to_g1_point`
 */
G1_INVALID_TO_BIG_COMPRESSED : Bytes48
G1_INVALID_TO_BIG_COMPRESSED = cFlag + Fp + 1 where
    cFlag = (1 << 383) // is compressed

/**
 * Test point for the decompression function `bytes48_to_g1_point`
 */
G1_INVALID_POINT_COMPRESSED : Bytes48
G1_INVALID_POINT_COMPRESSED = cFlag + bFlag + aFlag + 13 where
    cFlag = (1 << 383) // is compressed
    bFlag = (0 << 382) // not infinity
    aFlag = (1 << 381) // doesn't matter since invalid point

/**
 * Test point for the decompression function `bytes48_to_g1_point`
 */
G1_2P_COMPRESSED : Bytes48
G1_2P_COMPRESSED = cFlag + bFlag + aFlag + G1_2P.xCoord where
    cFlag = (1 << 383) // is compressed
    bFlag = (0 << 382) // not infinity
    aFlag = (1 << 381) // because the MSB of G1_2P.yCoord is '1'

/**
 * Test point for the decompression function `bytes48_to_g1_point`
 */
G1_7P_COMPRESSED : Bytes48
G1_7P_COMPRESSED = cFlag + bFlag + aFlag + G1_7P.xCoord where
    cFlag = (1 << 383) // is compressed
    bFlag = (0 << 382) // not infinity
    aFlag = (1 << 381) // because the MSB of G1_7P.yCoord is '0'

/**
 * Unit tests for `bytes48_to_g1_point`.
 * ```repl
 * :prove test_bytes48_to_g1_point G1_POINT_AT_INFINITY G1_INFINITY
 * :prove test_bytes48_to_g1_point G1_2P_COMPRESSED G1_2P
 * :prove test_bytes48_to_g1_point G1_7P_COMPRESSED G1_7P
 * ```
 */
test_bytes48_to_g1_point : Bytes48 -> G1Point -> Bit
property test_bytes48_to_g1_point bytes point =
    bytes48_to_g1_point bytes == point
