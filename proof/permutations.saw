enable_experimental;

Permutations <- cryptol_load "../spec/Permutations.cry";

let z3_solver = w4_unint_z3;

let uint64_t = llvm_int 64;

let setup_tuple (type : LLVMType) (name : String) = do {
  cfvTerm <- llvm_fresh_var name type;
  let setupVal = llvm_term cfvTerm;
  return (setupVal, cfvTerm);
};

// TODO get the .bc file by submoduling in https://github.com/ethereum/c-kzg-4844/blob/main/src/common/utils.c
m <- llvm_load_module "permutations.bc"; // Need the compiled C code equiv

let is_power_of_two_ok = do {
    (vimpl, vspec) <- (setup_tuple uint64_t "v");
    llvm_precond {{ vspec >= 1 }};
    llvm_execute_func[vimpl];
    llvm_return (llvm_term {{ Permutations::is_power_of_two (vspec) }});
};

llvm_verify m "is_power_of_two" [] true is_power_of_two_ok (z3_solver []);

let reverse_bits_ok = do {
    (vimpl, vspec) <- (setup_tuple uint64_t "v");
    llvm_execute_func[vimpl];
    llvm_return (llvm_term {{ reverse (vspec) }});
};

reverse_bits_ov <- llvm_verify m "reverse_bits" [] true reverse_bits_ok (z3_solver []);

let reverse_bits_limited_ok = do {
    (vimpl, vspec) <- (setup_tuple uint64_t "v");
    (oimpl, ospec) <- (setup_tuple uint64_t "order");
    llvm_precond {{ Permutations::is_power_of_two_bit (ospec)}};
    llvm_precond {{ (ospec > 1) }};
    llvm_execute_func[oimpl, vimpl];
    llvm_return (llvm_term {{ Permutations::reverse_bits_limited (ospec) (vspec) }});
};

llvm_verify m "reverse_bits_limited" [reverse_bits_ov] true reverse_bits_limited_ok (z3_solver []);
