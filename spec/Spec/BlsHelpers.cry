/**
 * The module contains functions that perform BLS operations.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#bls12-381-helpers
 */
module Spec::BlsHelpers where

import Common::Utils
import Spec::BlsEC
import Spec::BlsSerde

/**
 * BLS field elements are 256-bits long.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#custom-types
 */
type BlsFieldSize = 256
type BlsFieldElement = [BlsFieldSize]

/**
 * Specified by the consensus-specs.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#constants
 */
type BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513

/**
 * Compute the modular inverse of x
 *  i.e. return y such that x * y % BLS_MODULUS == 1
 * Precondition: x != 0 BLS_MODULUS
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#bls_modular_inverse
 * NOTE: Cryptol can not perform exponentiation with negative exponents,
 *  we cannot just execute `x^^(-1) % BLS_MODULUS` like the Python spec does.
 */
bls_modular_inverse : BlsFieldElement -> BlsFieldElement
bls_modular_inverse x = toIntegral (modular_inverse x') where
    x' = fromIntegral`{BLS_MODULUS} x

/**
 * Divide two field elements: x by y
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#div
 */
bls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement
bls_div x y = toIntegral (div_mod x' y') where
    x' = fromIntegral`{BLS_MODULUS} x
    y' = fromIntegral`{BLS_MODULUS} y

/**
 * Return x to power of [0, n-1].
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_powers
 * NOTE: this Cryptol function requires n >= 1, which is not the same constraint on the Python function,
 *  whose constraint is n >= 0.
 */
compute_powers : {n} (fin n, width n <= 64, n >= 2) => BlsFieldElement -> [n]BlsFieldElement
compute_powers x = powers where
        x' = fromIntegral`{BLS_MODULUS} x
        powers' = [x'] # [powers'@(i-1) * x' | i <- [1 .. n-1]]
        powers = [toIntegral xi' | xi' <- powers']

/**
 * Performs a multi-scalar multiplication between G1 `points` and `scalars`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#multi_exp
 */
g1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt256 -> G1Point
g1_multi_exp points scalars = results!0 where
    results = [G1_INFINITY] # [g1_add (results@i) (g1_multi (points@i) (scalars@i)) | i <- [0 .. len-1]]

/**
 * Deserialize the G1 bytes into a G1 point
 * @see https://github.com/ethereum/consensus-specs/blob/dcdcf25d8152cd078a9888eeddda4a550e1de009/tests/core/pyspec/eth2spec/utils/bls.py#L337
 * ```repl
 * :prove bytes48_to_G1 G1_POINT_AT_INFINITY == G1_INFINITY
 * :prove bytes48_to_G1 G1_2P_COMPRESSED == G1_2P
 * :prove bytes48_to_G1 G1_7P_COMPRESSED == G1_7P
 * ```
 */
bytes48_to_G1 : Bytes48 -> G1Point
bytes48_to_G1 bytes = decompress_G1 bytes

/**
 * Serialize the G1 point into G1 bytes
 * @see https://github.com/ethereum/consensus-specs/blob/dcdcf25d8152cd078a9888eeddda4a550e1de009/tests/core/pyspec/eth2spec/utils/bls.py#L315
 * ```repl
 * :prove g1_to_bytes48 G1_INFINITY == G1_POINT_AT_INFINITY
 * :prove g1_to_bytes48 G1_2P == G1_2P_COMPRESSED
 * :prove g1_to_bytes48 G1_7P == G1_7P_COMPRESSED
 * ```
 */
g1_to_bytes48 : G1Point -> Bytes48
g1_to_bytes48 point = compress_G1 point

/**
 * A KZG commitment is just a G1 point
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#custom-types
 */
type KZGCommitment = Bytes48

/**
 * BLS multiscalar multiplication in G1. This can be naively implemented using double-and-add.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#g1_lincomb
 * NOTE: we don't handle the case were there is an empty list of points or scalars provided.
 */
g1_lincomb : {n} (fin n, n >= 1) => [n]KZGCommitment -> [n]BlsFieldElement -> KZGCommitment
g1_lincomb points scalars = g1_to_bytes48 result where
    points_g1 = [bytes48_to_G1 point | point <- points]
    result = g1_multi_exp`{n} points_g1 scalars

/**
 * BLS Primitive root of unity.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#constants
 */
PRIMITIVE_ROOT_OF_UNITY : Z BLS_MODULUS
PRIMITIVE_ROOT_OF_UNITY = 7

/**
 * Compute the roots of unity for the `order`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_roots_of_unity
 * Precondition: `(BLS_MODULUS - 1) % order == 0`
 * Assertion: `order == n`
 */
compute_roots_of_unity : {n} (fin n, width n <= 64, n >= 2) => UInt64 -> [n]BlsFieldElement
compute_roots_of_unity order = assert (order == `n) "order must be equal to n" result where
        order' = toInteger order
        root_of_unity = pow_mod PRIMITIVE_ROOT_OF_UNITY ((`(BLS_MODULUS) - 1) / order')
        root_of_unity' = toIntegral root_of_unity
        result = compute_powers`{n} root_of_unity'

/*
 * ===============
 * Unit test suite
 * ===============
 */

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_bls_modular_inverse 1 1
 * :prove test_bls_modular_inverse 2 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001
 * :prove test_bls_modular_inverse 3 0x4d491a377113a8daccd13ab0066be558e27e6d5755543d54aaaaaaaa00000001
 * ```
 * NOTE: we just chose the values at "random." Checked against: https://planetcalc.com/3298/.
 */
test_bls_modular_inverse : BlsFieldElement -> BlsFieldElement -> Bit
property test_bls_modular_inverse x expectedY =
    bls_modular_inverse x == expectedY

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_bls_div 1 2 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001
 * :prove test_bls_div 13 1 13
 * :prove test_bls_div 57 13 0x1ac0b075a72457fcf8210a7802390a776218122813b0da27276276272762762c
 * ```
 * NOTE: we just chose the last value at "random"
 */
test_bls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement -> Bit
property test_bls_div x y expected =
    bls_div x y == expected

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_compute_powers`{2} 13 [13, 13^^2]
 * :prove test_compute_powers`{5} 13 [13, 13^^2, 13^^3, 13^^4, 13^^5]
 * ```
 * NOTE: we just chose these values at "random"
 */
test_compute_powers : {n} (fin n, width n <= 64, n >= 2) => BlsFieldElement -> [n]BlsFieldElement -> Bit
property test_compute_powers x expected =
    join (compute_powers`{n} x) == join expected

/**
 * Unit tests for `g1_multi_exp`.
 * ```repl
 * :prove test_g1_multi_exp`{1} [G1] [1] G1
 * :prove test_g1_multi_exp`{2} [G1, G1] [2, 3] G1_5P
 * :prove test_g1_multi_exp`{2} [G1_3P, G1_2P] [1, 2] G1_7P
 * :prove test_g1_multi_exp`{3} [G1_4P, G1_2P, G1_3P] [2, 3, 5] (g1_multi_exp`{2} [G1_5P, G1_7P] [3, 2])
 * ```
 */
test_g1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt256 -> G1Point -> Bit
property test_g1_multi_exp points scalars expected =
    g1_point_eq (g1_multi_exp points scalars) expected


/**
 * Unit tests for `g1_lincomb`.
 * ```repl
 * :prove test_g1_lincomb`{1} [G1_1P_COMPRESSED] [1] G1_1P_COMPRESSED
 * :prove test_g1_lincomb`{2} [G1_1P_COMPRESSED, G1_1P_COMPRESSED] [2, 5] G1_7P_COMPRESSED
 * :prove test_g1_lincomb`{3} [G1_2P_COMPRESSED, G1_2P_COMPRESSED, G1_1P_COMPRESSED] [1, 1, 3] G1_7P_COMPRESSED
 * :prove test_g1_lincomb`{3} [G1_3P_COMPRESSED, G1_2P_COMPRESSED, G1_1P_COMPRESSED] [1, 2, 0] G1_7P_COMPRESSED
 * ```
 */
 test_g1_lincomb : {n} (fin n, n >= 1) => [n]KZGCommitment -> [n]BlsFieldElement -> KZGCommitment -> Bit
property test_g1_lincomb points scalars commitment =
    g1_lincomb points scalars == commitment

/**
 * Unit tests for `g1_lincomb`.
 * ```repl
 * let bls_minus1 = fromIntegral`{BLS_MODULUS, 256} (`(BLS_MODULUS) - 1)
 * let bls_minus1_sqrd = bls_minus1^^2
 * :prove test_compute_roots_of_unity`{2} 2 [toIntegral bls_minus1, toIntegral bls_minus1_sqrd]
 * ```
 */
test_compute_roots_of_unity : {n} (fin n, width n <= 64, n >= 2) => UInt64 -> [n]BlsFieldElement -> Bit
property test_compute_roots_of_unity order roots =
    compute_roots_of_unity order == roots
