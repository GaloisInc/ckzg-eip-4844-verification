/**
 * The module contains functions that perform BLS operations.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#bls12-381-helpers
 */
module Spec::BlsHelpers where

import Common::Utils
import Spec::BlsEC
import Spec::BlsSerde

/**
 * BLS field elements are 256-bits long.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#custom-types
 */
type BlsFieldSize = 256
type BlsFieldElement = [BlsFieldSize]

/**
 * Specified by the consensus-specs.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#constants
 */
type BLS_MODULUS = 52435875175126190479447740508185965837690552500527637822603658699938581184513

/**
 * Compute the modular inverse of x
 *  i.e. return y such that x * y % BLS_MODULUS == 1
 * Precondition: x != 0 BLS_MODULUS
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#bls_modular_inverse
 * NOTE: Cryptol can not perform exponentiation with negative exponents,
 *  we cannot just execute `x^^(-1) % BLS_MODULUS` like the Python spec does.
 */
bls_modular_inverse : BlsFieldElement -> BlsFieldElement
bls_modular_inverse x = toIntegral (modular_inverse x') where
    x' = fromIntegral`{BLS_MODULUS} x

/**
 * Divide two field elements: x by y
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#div
 */
bls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement
bls_div x y = toIntegral (div_mod x' y') where
    x' = fromIntegral`{BLS_MODULUS} x
    y' = fromIntegral`{BLS_MODULUS} y

/**
 * Return x to power of [0, n-1].
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_powers
 * NOTE: this Cryptol function requires n >= 1, which is not the same constraint on the Python function,
 *  whose constraint is n >= 0.
 */
compute_powers : {n} (fin n, width n <= 64, n >= 2) => BlsFieldElement -> [n]BlsFieldElement
compute_powers x = powers where
        x' = fromIntegral`{BLS_MODULUS} x
        powers' = [x'] # [powers'@(i-1) * x' | i <- [1 .. n-1]]
        powers = [toIntegral xi' | xi' <- powers']

/**
 * Performs a multi-scalar multiplication between G1 `points` and `scalars`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#multi_exp
 */
g1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt64 -> G1Point
g1_multi_exp points scalars = results!0 where
    results = [G1_INFINITY] # [g1_add (results@i) (g1_multi (points@i) (scalars@i)) | i <- [0 .. len-1]]

/**
 * Deserialize the G1 bytes into a G1 point
 * ```repl
 * :prove bytes48_to_G1 G1_POINT_AT_INFINITY == G1_INFINITY
 * :prove bytes48_to_G1 G1_2P_COMPRESSED == G1_2P
 * :prove bytes48_to_G1 G1_7P_COMPRESSED == G1_7P
 * ```
 */
bytes48_to_G1 : Bytes48 -> G1Point
bytes48_to_G1 bytes = decompress_G1 bytes

/**
 * Serialize the G1 point into G1 bytes
 * ```repl
 * :prove g1_to_bytes48 G1_INFINITY == G1_POINT_AT_INFINITY
 * :prove g1_to_bytes48 G1_2P == G1_2P_COMPRESSED
 * :prove g1_to_bytes48 G1_7P == G1_7P_COMPRESSED
 * ```
 */
g1_to_bytes48 : G1Point -> Bytes48
g1_to_bytes48 point = compress_G1 point

/*
 * ===============
 * Unit test suite
 * ===============
 */

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_bls_modular_inverse 1 1
 * :prove test_bls_modular_inverse 2 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001
 * :prove test_bls_modular_inverse 3 0x4d491a377113a8daccd13ab0066be558e27e6d5755543d54aaaaaaaa00000001
 * ```
 * NOTE: we just chose the values at "random." Checked against: https://planetcalc.com/3298/.
 */
test_bls_modular_inverse : BlsFieldElement -> BlsFieldElement -> Bit
property test_bls_modular_inverse x expectedY =
    bls_modular_inverse x == expectedY

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_bls_div 1 2 0x39f6d3a994cebea4199cec0404d0ec02a9ded2017fff2dff7fffffff80000001
 * :prove test_bls_div 13 1 13
 * :prove test_bls_div 57 13 0x1ac0b075a72457fcf8210a7802390a776218122813b0da27276276272762762c
 * ```
 * NOTE: we just chose the last value at "random"
 */
test_bls_div : BlsFieldElement -> BlsFieldElement -> BlsFieldElement -> Bit
property test_bls_div x y expected =
    bls_div x y == expected

/**
 * Unit tests for `bls_modular_inverse`.
 * ```repl
 * :prove test_compute_powers`{2} 13 [13, 13^^2]
 * :prove test_compute_powers`{5} 13 [13, 13^^2, 13^^3, 13^^4, 13^^5]
 * ```
 * NOTE: we just chose these values at "random"
 */
test_compute_powers : {n} (fin n, width n <= 64, n >= 2) => BlsFieldElement -> [n]BlsFieldElement -> Bit
property test_compute_powers x expected =
    join (compute_powers`{n} x) == join expected

/**
 * Unit tests for `g1_multi_exp`.
 * ```repl
 * :prove test_g1_multi_exp`{1} [G1] [1] G1
 * :prove test_g1_multi_exp`{2} [G1, G1] [2, 3] G1_5P
 * :prove test_g1_multi_exp`{2} [G1_3P, G1_2P] [1, 2] G1_7P
 * :prove test_g1_multi_exp`{3} [G1_4P, G1_2P, G1_3P] [2, 3, 5] (g1_multi_exp`{2} [G1_5P, G1_7P] [3, 2])
 * ```
 */
test_g1_multi_exp : {len} (fin len, len >= 1) => [len]G1Point -> [len]UInt64 -> G1Point -> Bit
property test_g1_multi_exp points scalars expected =
    g1_point_eq (g1_multi_exp points scalars) expected
