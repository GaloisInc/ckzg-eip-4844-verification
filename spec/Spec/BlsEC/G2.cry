/**
 * These functions are specific to the BLS curve and specifically the
 *  G2 ECC points with coordinates in the quadratic extension field Fq2.
 *
 * The Deneb Python specs has an option to use the py_ecc library for these operations.
 * This modules functions are based off of py_ecc.
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py
 */
module Spec::BlsEC::G2 where

import Common::ModArith
import Common::Utils
import Spec::BlsEC::Field
import Spec::BlsEC::Poly(poly_extended_euclidean)

/**
 * A G2 point is comprised of two Fq2 elements, or sets of coefficients, each of degree two.
 * Each element is comprised of a real and imaginary coeffsicient.
 */
type Fq2 =
    { real : Z Fq   // Real number coeffsicient
    , imag : Z Fq   // Imaginary number coeffsicient
    }

/**
 * The modulus coefficients for the quadratic extension field Fq2.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_properties.py#L30
 */
FQ2_MODULUS_COEFFICIENTS : Fq2
FQ2_MODULUS_COEFFICIENTS =
    { real = 1
    , imag = 0
    }

/**
 * Twisted curve over Fq2.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L30
 */
FQ2_B2 : Fq2
FQ2_B2 =
    { real = 4
    , imag = 4
    }

/**
 * Addition of two Fq2 elements.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L232
 * ```repl
 * :prove G2.yCoeffs ~+~ G2.xCoeffs == G2_y_plus_x
 * ```
 */
(~+~) : Fq2 -> Fq2 -> Fq2
(~+~) coeffs1 coeffs2 =
    { real = coeffs1.real + coeffs2.real
    , imag = coeffs1.imag + coeffs2.imag
    }

/**
 * Subtraction of two Fq2 elements.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L240
 * ```repl
 * :prove G2.yCoeffs ~-~ G2.xCoeffs == G2_y_minus_x
 * ```
 */
(~-~) : Fq2 -> Fq2 -> Fq2
(~-~) coeffs1 coeffs2 =
    { real = coeffs1.real - coeffs2.real
    , imag = coeffs1.imag - coeffs2.imag
    }

/**
 * Multiplication of two Fq2 elements.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L251
 * ```repl
 * :prove G2.xCoeffs ~*~ G2.xCoeffs == G2_xSquared
 * :prove G2.xCoeffs ~*~ G2.xCoeffs ~*~ G2.xCoeffs == G2_xCubed
 * ```
 */
(~*~) : Fq2 -> Fq2 -> Fq2
(~*~) coeffs1 coeffs2 = {real = new_real, imag = new_imag} where
    b = [real_part, combination, imaginary_part]
    real_part = coeffs1.real * coeffs2.real
    imaginary_part = coeffs1.imag * coeffs2.imag
    combination = (coeffs1.real * coeffs2.imag) + (coeffs1.imag * coeffs2.real)
    new_real = (b@0) - (imaginary_part * FQ2_MODULUS_COEFFICIENTS.real)
    new_imag = (b@1) - (imaginary_part * FQ2_MODULUS_COEFFICIENTS.imag)

/**
 * Multiplication of an integer and Fq2 element.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L249
 * ```repl
 * :prove G2.xCoeffs ~* 2 == G2_xDoubled
 * :prove 2 *~ G2.xCoeffs == G2_xDoubled
 * ```
 */
(*~) : Integer -> Fq2 -> Fq2
(*~) value coeffs = {real = new_real, imag = new_imag} where
    new_real = coeffs.real * (fromInteger value)
    new_imag = coeffs.imag * (fromInteger value)

(~*) : Fq2 -> Integer -> Fq2
(~*) coeffs value = value *~ coeffs

/**
 * Division of two Fq2 elements.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L280
 * ```repl
 * :prove G2.xCoeffs ~/~ G2.xCoeffs == {real = 1, imag = 0}
 * :prove G2.yCoeffs ~/~ G2.xCoeffs == G2_y_div_mod_x
 * ```
 */
(~/~) : Fq2 -> Fq2 -> Fq2
(~/~) coeffs1 coeffs2 = coeffs1 ~*~ (fq2_inv coeffs2)

/**
 * Compute the inverse of a Fq2 element.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L302
 * ```repl
 * :prove fq2_inv G2.xCoeffs == G2_xInverse
 * :prove fq2_inv (fq2_inv G2.xCoeffs) == G2.xCoeffs
 * :prove fq2_inv G2.yCoeffs == G2_yInverse
 * :prove fq2_inv (fq2_inv G2.yCoeffs) == G2.yCoeffs
 * ```
 */
fq2_inv : Fq2 -> Fq2
fq2_inv coeffs = {real = real, imag = imag} where
    lm = [1, 0, 0]
    hm = [0, 0, 0]
    low = [coeffs.real, coeffs.imag, 0]
    high = [FQ2_MODULUS_COEFFICIENTS.real, FQ2_MODULUS_COEFFICIENTS.imag, 1]
    (real, imag) = poly_extended_euclidean lm low hm high

/**
 * Exponentiation of a G2 coeffsicient by some scalar.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L291
 * ```repl
 * :prove G2.xCoeffs~^^2 == G2_xSquared
 * :prove G2.xCoeffs~^^3 == G2_xCubed
 * ```
 */
(~^^) : Fq2 -> Integer -> Fq2
(~^^) coeffs scalar =
    if scalar == 0 then
        {real = 1, imag = 0}
     | scalar == 1 then
        coeffs
     | scalar % 2 == 0 then
        (coeffs ~*~ coeffs) ~^^ (scalar / 2)
     else
        ((coeffs ~*~ coeffs) ~^^ (scalar / 2)) ~*~ coeffs

/**
 * Equality of Fq2 elements.
 */
(~==~) : Fq2 -> Fq2 -> Bit
(~==~) coeffs1 coeffs2 =
    (coeffs1.real == coeffs2.real) && (coeffs1.imag == coeffs2.imag)

/**
 * Negate the Fq2 element.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L355
 * ```repl
 * :prove fq2_neg (fq2_neg G2.xCoeffs) == G2.xCoeffs
 * ```
 */
fq2_neg : Fq2 -> Fq2
fq2_neg coeffs = {real = new_real, imag = new_imag} where
    new_real = -coeffs.real
    new_imag = -coeffs.imag

/**
 * G2 elliptic curve point.
 * This is the quadratic extension field (Fq2) for the field Fq (G1).
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L367
 *
 * NOTE: by using the Z type, all modular arithmetic
 *  is handled automatically and there is no potential
 *  for any overflow errors.
 */
type G2Point =
    { xCoeffs : Fq2
    , yCoeffs : Fq2
    }

/**
 * Representation of G2 point at infinity.
 *
 * NOTE: ((0,0),(0,0)) isn't actually the point at infinity, but since we
 *  can't use enums here and ((0,0),(0,0)) is not on the curve, it's an
 *  acceptable substitute.
 */
G2_INFINITY : G2Point
G2_INFINITY =
    { xCoeffs =
        { real = 0
        , imag = 0
        }
    , yCoeffs =
        { real = 0
        , imag = 0
        }
    }

/**
 * Generator for twisted curve over Fq2.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L44
 */
G2 : G2Point
G2 =
    { xCoeffs =
        { real = 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160
        , imag = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758
        }
    , yCoeffs =
        { real = 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
        , imag = 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582
        }
    }

/**
 * G2 doubled. Computed using py_ecc: `normalize(double(G2))`.
 */
G2_2P : G2Point
G2_2P =
    { xCoeffs =
        { real = 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891
        , imag = 1586560233067062236092888871453626466803933380746149805590083683748120990227823365075019078675272292060187343402359
        }
    , yCoeffs =
        { real = 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545
        , imag = 2374407843478705782611042739236452317510200146460567463070514850492917978226342495167066333366894448569891658583283
        }
    }

/**
 * G2 tripled. Computed using py_ecc: `normalize(add(G2, double(G2)))`.
 */
G2_3P : G2Point
G2_3P =
    { xCoeffs =
        { real = 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478
        , imag = 1418901263980595683832511076652430035654903023556505873032297534993731256453342997202098832403658787934376638965468
        }
    , yCoeffs =
        { real = 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066
        , imag = 1376945178829045108008380835987620979304438294788415956605678509674588356753313865659068546846109894276784773457993
        }
    }

/**
 * G2 multiplied by 6. Computed using py_ecc: `normalize(multiply(G2, 6))`.
 */
G2_6P : G2Point
G2_6P =
    { xCoeffs =
        { real = 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231
        , imag = 608866484358724393780037751128594231300217318157170134017274809385436427203952108566113171210510640978002034144337
        }
    , yCoeffs =
        { real = 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444
        , imag = 1315309522598195877039488735068285781409574791250756219351720987511623939545034443010380218936398442802560800338945
        }
    }

/**
 * Determines whether or not the given point is on the G2 curve.
 * The point must satisfy the EC equation: y^^2 = x^^3 + 4
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L71
 * ```repl
 * :prove g2_is_valid_point G2
 * :prove g2_is_valid_point G2_2P
 * ```
 */
g2_is_valid_point : G2Point -> Bit
g2_is_valid_point point =
    (y~^^2) ~-~ (x~^^3) == FQ2_B2
    where
        x = point.xCoeffs
        y = point.yCoeffs

/**
 * Negate a G2 point.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L135
 * ```repl
 * :prove g2_negate G2 == G2_Negated
 * :prove g2_negate (g2_negate G2) == G2
 * ```
 */
g2_negate : G2Point -> G2Point
g2_negate point = newPoint where
    x = point.xCoeffs
    y = point.yCoeffs
    newPoint =
        { xCoeffs = x
        , yCoeffs = fq2_neg y
        }

/**
 * Double a G2 point.
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L84
 * ```repl
 * :prove g2_double G2 == G2_2P
 * ```
 */
g2_double : G2Point -> G2Point
g2_double point = newPoint where
    x = point.xCoeffs
    y = point.yCoeffs
    m = (3 *~ (x~^^2)) ~/~ (2 *~ y)
    newX = (m~^^2) ~-~ (2 *~ x)
    newY = (m ~*~ (x ~-~ newX)) ~-~ y
    newPoint =
        { xCoeffs = newX
        , yCoeffs = newY
        }

/**
 * Add two G2 points
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L95
 * ```repl
 * :prove g2_add G2 G2 == G2_2P
 * :prove g2_add G2 G2_2P == G2_3P
 * :prove g2_add G2_3P G2_3P == G2_6P
 * ```
 */
g2_add : G2Point -> G2Point -> G2Point
g2_add p1 p2 =
    if g2_point_eq p1 G2_INFINITY then p2
    else if g2_point_eq p2 G2_INFINITY then p1
    else if (x2 == x1) && (y2 == y1) then
        g2_double p1
    else
        { xCoeffs = newX
        , yCoeffs = newY
        }
    where
    x1 = p1.xCoeffs
    y1 = p1.yCoeffs
    x2 = p2.xCoeffs
    y2 = p2.yCoeffs
    m = (y2 ~-~ y1) ~/~ (x2 ~-~ x1)
    newX = m~^^2 ~-~ x1 ~-~ x2
    newY = m ~*~ (x1 ~-~ newX) ~-~ y1

/**
 * Helper function for testing point equality.
 * ```repl
 * :prove g2_point_eq G2 G2
 * ```
 */
g2_point_eq : G2Point -> G2Point -> Bit
g2_point_eq p1 p2 =
    (p1.xCoeffs ~==~ p2.xCoeffs) && (p1.yCoeffs ~==~ p2.yCoeffs)

/*
 * ==========
 * Unit Tests
 * ==========
 */

/**
 * G2.xCoeffs multipled by two. Computed using py_ecc.
 */
G2_xDoubled : Fq2
G2_xDoubled =
    { real = 705402139174933236374278232022120289780059905585550480439817288479587571471430053746695200687730351905523852606320
    , imag = 2115879133266760026524729803771659117416057831014287231986688276459238999047079000424331497079678371637877254171729
    }

/**
 * G2.xCoeffs squared. Computed using py_ecc.
 */
G2_xSquared : Fq2
G2_xSquared =
    { real = 1997086149283677522843833040423074048426674013790346437450988890364808601048656494674186077061491944389142492819694
    , imag = 3113349101563180256960455051481244719726682130931247942710023183696345206282753395927436272834951815958170074391256
    }

/**
 * G2.xCoeffs cubed. Computed using py_ecc.
 */
G2_xCubed : Fq2
G2_xCubed =
    { real = 3341065098200961989598748404381324054605449840948293400785922068969583005812936621662354076014412578129291257715484
    , imag = 2133050398774337206222816300118221327418763981033055222570091459262312519047975404484651902003138703421962555090218
    }

/**
 * G2.xCoeffs - G2.yCoeffs. Computed using py_ecc.
 */
G2_y_minus_x : Fq2
G2_y_minus_x =
    { real = 1632449532699825317380915405166111493410839025422880490639470020826550940638108691550521503919468808688732414044745
    , imag = 1870818876469786139193731976758160400328152687915953296697712908626373202724554996990127355752626211775441853413611
    }

/**
 * G2.xCoeffs + G2.yCoeffs. Computed using py_ecc.
 */
G2_y_plus_x : Fq2
G2_y_plus_x =
    { real = 2337851671874758553755193637188231783190898931008430971079287309306138512109538745297216704607199160594256266651065
    , imag = 3986698009736546165718461780529819517744210518930240528684401185085612201771633997414458852832304583413319107585340
    }

/**
 * G2.yCoeffs / G2.xCoeffs. Computed using py_ecc.
 */
G2_y_div_mod_x : Fq2
G2_y_div_mod_x =
    { real = 2645964961145567287646174681515652840605182444869364111679220104429646387260976011822898928226591963576020240426619
    , imag = 3656195751079888906744826605664754595376734064625263022628224160781596224005157110042338963344577397675474692059176
    }

/**
 * G2.xCoeffs inverse. Computed using py_ecc.
 */
G2_xInverse : Fq2
G2_xInverse =
    { real = 1223514866584400226619392018844575446040489926980124362465220784014275923982521236729115905530146470033177964357563
    , imag = 3495453419063574139925455551631318136524378768480668459768684498547208492074727172949503320416899422709399085629096
    }

/**
 * G2.yCoeffs inverse. Computed using py_ecc.
 */
G2_yInverse : Fq2
G2_yInverse =
    { real = 3828301281232776537393462114696026453820925117135598932697882187079936548530569912296382199133331215710911400309693
    , imag = 1450185639544495128598198914056492809111071767684112182252696543466687995844478949870392653614483391964324409513904
    }

/**
 * G2 negated. Computed using py_ecc: `normalize(neg(G2))`.
 */
G2_Negated : G2Point
G2_Negated =
    { xCoeffs =
        { real = 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160
        , imag = 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758
        }
    , yCoeffs =
        { real = 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882
        , imag = 3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205
        }
    }

/*
 * ==========
 * Properties
 * ==========
 */

/**
 * Verify that coeffsicient addition is commutative.
 * ```repl
 * :prove fq2_addition_commutative
 * ```
 */
fq2_addition_commutative : Fq2 -> Fq2 -> Bit
property fq2_addition_commutative a b =
    a ~+~ b == b ~+~ a

/**
 * Verify that coeffsicient multiplication is commutative.
 * ```repl
 * :prove fq2_multiplication_commutative
 * ```
 */
fq2_multiplication_commutative : Fq2 -> Fq2 -> Bit
property fq2_multiplication_commutative a b =
    a ~*~ b == b ~*~ a

/**
 * Verify that coeffsicient subtraction is not commutative,
 *   unless both coefficients are equal.
 * ```repl
 * :prove fq2_subtraction_not_commutative
 * ```
 */
fq2_subtraction_not_commutative : Fq2 -> Fq2 -> Bit
property fq2_subtraction_not_commutative a b = precondition ==> statement where
    precondition = a != b
    statement = a ~-~ b != b ~-~ a

/**
 * Verify that squaring a coeffsicient is that same using
 *  either multiplication or exponentiation.
 * ```repl
 * :prove fq2_squared_equiv
 * ```
 */
fq2_squared_equiv : Fq2 -> Bit
property fq2_squared_equiv c =
    c~^^2 == c ~*~ c

/**
 * Verify that coefficients equality is commutative.
 * ```repl
 * :prove fq2_equality_commutative
 * ```
 */
fq2_equality_commutative : Fq2 -> Fq2 -> Bit
property fq2_equality_commutative a b =
    a ~==~ b == b ~==~ a
