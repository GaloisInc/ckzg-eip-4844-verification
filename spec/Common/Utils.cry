/*
 * This module contains helper functions unrelated to the consensus-specs.
 */
module Common::Utils where

type BYTE_WIDTH = 8

type UInt64 = [64]

/**
 * Convert a `Bit` to a 1-bit value.
 * We use this function because SAW cannot convert
 *  the `Bit` type internally to an LLVM integer type.
 * ```repl
 * :prove bit_to_bool True == 1
 * :prove bit_to_bool False == 0
 * ```
 */
bit_to_bool : Bit -> [1]
bit_to_bool b = if b then 1 else 0

/**
 * Convert a 1-bit value to a `Bit`.
 * ```repl
 * :prove bool_to_bit 1 == True
 * :prove bool_to_bit 0 == False
 * ```
 */
bool_to_bit : [1] -> Bit
bool_to_bit b = if b == 1 then True else False

/**
 * Convert an Integral value of 'n' bits to a `Bit`.
 * ```repl
 * :prove int_to_bit`{8} 1 == True
 * :prove int_to_bit`{8} 0 == False
 * ```
 */
int_to_bit : {n} (fin n, n >= 1) => [n] -> Bit
int_to_bit b = if b == 1 then True else False

/**
 * Calculates the gcd and Bezout coefficients,
 *   using the Extended Euclidean Algorithm (recursive).
 *   (Source: https://extendedeuclideanalgorithm.com/code)
 * ```repl
 * :prove xgcd 7 5 1 0 0 1 == (1, -2, 3)
 * ```
 */
xgcd : Integer -> Integer -> Integer -> Integer -> Integer -> Integer -> (Integer, Integer, Integer)
xgcd a b s1 s2 t1 t2 =
    if b == 0 then
        (abs (a), 1, 0)
    // if r == 0, then b will be the gcd and
    //    s2, t2 the Bezout coefficients
    else if r == 0 then
        (abs (b), s2, t2)
    else
        xgcd b r s2 s3 t2 t3
    where
        q = a / b
        r = a - q * b
        s3 = s1 - q * s2
        t3 = t1 - q * t2

/**
 * Calculates the multiplicative inverse of a number 'x' mod 'm',
 *  using the Extended Euclidean Algorithm. If 'x' does not have a
 *  multiplicative inverse mod 'm', then return 0.
 *  (Source: https://extendedeuclideanalgorithm.com/code)
 * ```repl
 * :prove multinv 3 7 == 5
 * :prove multinv 88831 319 == 167
 * ```
 */
multinv : Integer -> Integer -> Integer
multinv x m =
    // 'b' only has a multiplicative inverse if the 'gcd' is 1
    if gcd == 1
    then t % m
    else 0
    // Get the 'gcd' and the second Bezout coefficient 't' from
    //  the Extended Euclidean Algorithm. Note that 's' is unused.
    //  Default values for the last four parameters are standard.
    where (gcd, s, t) = xgcd m x 1 0 0 1

/**
 * Compute the modular inverse of x
 *  i.e. return y such that x * y % modulus == 1
 * Precondition: x != 0
 * ```repl
 * :prove modular_inverse 7492 319 == 177
 * :prove modular_inverse (-3) 319 == 106
 * ```
 * NOTE: we just chose the values at "random." Checked against: https://planetcalc.com/3298/.
 */
modular_inverse : Integer -> Integer -> Integer
modular_inverse x modulus = multinv x' modulus where
    x' = if x < 0 then x % modulus
         else x

/**
 * Divide two field elements: x by y
 * ```repl
 * :prov div 3 7492 319 == 212
 * :prov div 3 (-7492) 319 == 107
 * ```
 */
div : Integer -> Integer -> Integer -> Integer
div x y modulus = (x * (modular_inverse y modulus)) % modulus

/**
 * Exponentiation in the specified modulo field `n`.
 * @see https://github.com/ethereum/c-kzg-4844/blob/main/src/common/fr.c#L93
 * ```repl
 * :prove pow`{7} 3 2 == 2
 * :prove pow`{2} 1 18 == 1
 * :prove pow`{3} 0 5 == 0
 */
pow : {n} (fin n, n >= 1) => Integer -> Integer -> Integer
pow base exp = fromZ (((fromInteger base) : Z n) ^^ exp)
