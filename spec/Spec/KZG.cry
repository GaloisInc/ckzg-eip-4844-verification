/**
 * The module contains functions that perform the BLS KZG operations.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#kzg
 */
module Spec::KZG where

import Common::ModArith
import Spec::BlsEC::Curve
import Spec::BlsEC::Field
import Spec::BlsEC::G1
import Spec::BlsEC::GP
import Spec::BlsEC::Pairing
import Spec::BlsHelpers
import Spec::BlsSerde
import Spec::Permutations
import Spec::Polynomials
import Spec::TrustedSetup

/**
 * Create the polynomial commitment for the given `Blob`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#blob_to_kzg_commitment
 */
blob_to_kzg_commitment : Blob -> KZGCommitment
blob_to_kzg_commitment blob =
    g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) (blob_to_polynomial blob)

/**
 * Given `y == p(z)` for a polynomial `p(x)`, compute `q(z)`: the KZG quotient polynomial evaluated at `z` for the
 *  special case where `z` is in roots of unity.
 * For more details, read https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html section "Dividing
 *  when one of the points is zero". The code below computes q(x_m) for the roots of unity special case.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_quotient_eval_within_domain
 * NOTE: Test found in 'Test/KZG/ComputeQuotient/TV1.cry'
 */
compute_quotient_eval_within_domain : BlsFieldElement -> Polynomial -> BlsFieldElement -> BlsFieldElement
compute_quotient_eval_within_domain z polynomial y = toIntegral result where
    result = sum [compute i | i <- [0 .. (FIELD_ELEMENTS_PER_BLOB-1)]]
    f i = (fromIntegral (polynomial@i)) - (fromIntegral y)
    omega i = fromIntegral`{BLS_MODULUS} (ROOTS_OF_UNITY_BRP@i)
    numerator i = (f i) * (omega i)
    // Adding the BLS_MODULUS doesn't affect the computation because it is modular arithmetic with that modulus
    denominator i = z' * (z' - (omega i))
    z' = fromIntegral z
    // Skip the evaluation point (z) in the sum
    compute i = if omega i != z' then div_mod (numerator i) (denominator i) else 0

/**
 * Helper function for `compute_kzg_proof` and `compute_blob_kzg_proof`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_kzg_proof_impl
 * Called by `compute_kzg_proof` for which we have a test vector.
 */
compute_kzg_proof_impl : Polynomial -> BlsFieldElement -> (KZGProof, BlsFieldElement)
compute_kzg_proof_impl polynomial z = (proof, y) where
    // For all x_i, compute p(x_i) - p(z)
    y = evaluate_polynomial_in_evaluation_form polynomial z
    polynomial_shifted = [(fromIntegral`{BLS_MODULUS} p) - (fromIntegral y) | p <- polynomial]
    // For all x_i, compute (x_i - z)
    denominator_poly = [(fromIntegral`{BLS_MODULUS} x) - (fromIntegral z) | x <- ROOTS_OF_UNITY_BRP]
    // Compute the quotient polynomial directly in evaluation form
    quotient_polynomial = [quotient i a b | a <- polynomial_shifted | b <- denominator_poly | i <- [0 .. FIELD_ELEMENTS_PER_BLOB-1]]
    // Handle the conditional computation of computing the quotient
    quotient : Integer -> Z BLS_MODULUS -> Z BLS_MODULUS -> BlsFieldElement
    quotient i a b =
        if b == 0 then
            // The denominator is zero hence `z` is a root of unity: we must handle it as a special case.
            // This case can only happen once at most.
            compute_quotient_eval_within_domain (ROOTS_OF_UNITY_BRP@i) polynomial y
        else
            // Compute: q(x_i) = (p(x_i) - p(z)) / (x_i - z).
            toIntegral (div_mod`{BLS_MODULUS} a b)
    proof = g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) quotient_polynomial

/**
 * Compute KZG proof at point `z` for the polynomial represented by `blob`.
 * Do this by computing the quotient polynomial in evaluation form: q(x) = (p(x) - p(z)) / (x - z).
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_kzg_proof
 * NOTE: Test found in 'Test/KZG/ComputeProof/TV1.cry'
 */
compute_kzg_proof : Blob -> Bytes32 -> (KZGProof, Bytes32)
compute_kzg_proof blob z_bytes = (proof, y) where
    polynomial = blob_to_polynomial blob
    (proof, y') = compute_kzg_proof_impl polynomial (bytes_to_bls_field z_bytes)
    y = split`{BYTES_PER_FIELD_ELEMENT} y'
   
/**
 * Verify KZG proof that ``p(z) == y`` where ``p(z)`` is the polynomial represented by ``polynomial_kzg``.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#verify_kzg_proof_impl
 * Review with Galois' specification in the branch https://github.com/GaloisInc/ckzg-eip-4844-verification/tree/spec/feature/verify-kzg-proof
 *      -   Line https://github.com/GaloisInc/ckzg-eip-4844-verification/blob/861c606e5ec2191dd93dd4fb0c3cff32da8bd921/spec/Spec/KZG.cry#L85
 * Potential issues in the Python specification: 
 *      1.  The input z in bls.multiply(bls.G2(), -z) is with type BLSFieldElement, i.e., uint256, in the Python specification,
 *          but the second argument of bls.multiply in the py_ecc library is with type int.
 *          @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L114
 */
verify_kzg_proof_impl : KZGCommitment -> BlsFieldElement -> BlsFieldElement -> KZGProof -> Bit
verify_kzg_proof_impl commitment z y proof = result where
    G2_multi_neg_z = g2_multi G2 ((`(BLS_MODULUS) - z) % `(BLS_MODULUS))
    X_minus_z = g2_add (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)) G2_multi_neg_z
    G1_multi_neg_y = g1_multi G1 ((`(BLS_MODULUS) - y) % `(BLS_MODULUS))
    P_minus_y = g1_add (bytes48_to_G1 commitment) G1_multi_neg_y
    neg_G2 = g2_negate G2
    proof_in_G1 = bytes48_to_G1 proof
    result = pairing_check ((P_minus_y, neg_G2), (proof_in_G1, X_minus_z))

/**
 * Verify KZG proof that ``p(z) == y`` where ``p(z)`` is the polynomial represented by ``polynomial_kzg``.
 * Receives inputs as bytes.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#verify_kzg_proof
 * Review with Galois' specification in the branch https://github.com/GaloisInc/ckzg-eip-4844-verification/tree/spec/feature/verify-kzg-proof
 * Should we go with assert commands?
 */
verify_kzg_proof : Bytes48 -> Bytes32 -> Bytes32 -> Bytes48 -> Bit
verify_kzg_proof commitment_bytes z_bytes y_bytes proof_bytes = 
    assert  ((length commitment_bytes) == `(BYTES_PER_COMMITMENT)) 
            error_msg_for_commitment 
            assert  ((length z_bytes) == `(BYTES_PER_FIELD_ELEMENT))
                    error_msg_for_z_bytes
                    assert  ((length y_bytes) == `(BYTES_PER_FIELD_ELEMENT)) 
                            error_msg_for_y_bytes
                            assert  ((length proof_bytes) == `(BYTES_PER_PROOF))
                                    error_msg_for_proof_bytes
                                    result where
                                        error_msg_for_commitment = "The length of commitment must be BYTES_PER_COMMITMENT"
                                        error_msg_for_z_bytes = "The length of z_bytes must be BYTES_PER_FIELD_ELEMENT"
                                        error_msg_for_y_bytes = "The length of y_bytes must be BYTES_PER_FIELD_ELEMENT"
                                        error_msg_for_proof_bytes = "The length of proof_bytes must be BYTES_PER_PROOF"
                                        commitment = bytes_to_kzg_commitment commitment_bytes
                                        z = bytes_to_bls_field z_bytes
                                        y = bytes_to_bls_field y_bytes
                                        proof = bytes_to_kzg_proof proof_bytes 
                                        result = verify_kzg_proof_impl (commitment) (z) (y) (proof)

padding_zeros : [16][8] -> [BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB][8]
padding_zeros value = result where
    result = (zero : [BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB - 16][8]) # value

/**
 * Return the Fiat-Shamir challenge required by the rest of the protocol.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#hash_to_bls_field
 * Discuss with Galois:
 *      -   KZG_ENDIANNESS
 *      -   Overflow in data = blob + degree_poly + FIAT_SHAMIR_PROTOCOL_DOMAIN_with_leading_zeros + commitment_in_bytes_with_leading_zeros
 */
compute_challenge: Blob -> KZGCommitment -> BlsFieldElement
compute_challenge blob commitment = result where
    degree_poly = groupBy`{8,BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB} `(FIELD_ELEMENTS_PER_BLOB)
    FIAT_SHAMIR_PROTOCOL_DOMAIN_with_leading_zeros = (zero : [BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB - 16][8]) # FIAT_SHAMIR_PROTOCOL_DOMAIN
    commitment_in_bytes = groupBy`{8, 48} commitment
    commitment_in_bytes_with_leading_zeros = (zero : [BYTES_PER_FIELD_ELEMENT * FIELD_ELEMENTS_PER_BLOB - 48][8]) # commitment_in_bytes
    data = blob + degree_poly + FIAT_SHAMIR_PROTOCOL_DOMAIN_with_leading_zeros + commitment_in_bytes_with_leading_zeros
    result = hash_to_bls_field(data)


/*
 * ======================
 * Test Vector Generators
 * ======================
 */

/**
 * This function is used to generate a random, but valid data `Blob`.
 */
valid_blob_generator : Blob -> Blob
valid_blob_generator blob = assert (blob != blob') "error" blob' where
    x = [bytes | bytes <- (groupBy`{BYTES_PER_FIELD_ELEMENT} blob)]
    y = map (\b -> (join b)) x
    y' = map (\b -> b % `BLS_MODULUS) y
    x' = [groupBy`{8} poly | poly <- y']
    blob' = join x'

/**
 * This function is used to generate a random, valid Z bytes.
 */
z_bytes_generator : Bytes32 -> Bytes32
z_bytes_generator z = z