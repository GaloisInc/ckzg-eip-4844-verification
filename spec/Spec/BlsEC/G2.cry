/**
 * These functions are specific to the BLS curve and specifically the
 *  G2 ECC points with coordinates in the quadratic extension field Fq2.
 *
 * The Deneb Python specs has an option to use the py_ecc library for these operations.
 * This module's functions are based off of py_ecc.
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py
 */
module Spec::BlsEC::G2 where

import Common::ModArith
import Common::Utils
import Spec::BlsEC::Field
import Spec::BlsEC::FQP

/**
 * The order of Fq2.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls/constants.py#L9C1-L9C21
 */
FQ2_ORDER : Integer
FQ2_ORDER = `(Fq)^^2 - 1

/**
 * Twisted curve over Fq2.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L30
 */
FQ2_B2 : Fq2
FQ2_B2 = [4, 4]

/**
 * G2 elliptic curve point.
 * This is the quadratic extension field (Fq2) for the field Fq (G1).
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/fields/field_elements.py#L367
 *
 * NOTE: by using the Z type, all modular arithmetic
 *  is handled automatically and there is no potential
 *  for any overflow errors.
 */
type G2Point =
    { xCoeffs : Fq2
    , yCoeffs : Fq2
    }

/**
 * Representation of G2 point at infinity.
 *
 * NOTE: ((0,0),(0,0)) isn't actually the point at infinity, but since we
 *  can't use enums here and ((0,0),(0,0)) is not on the curve, it's an
 *  acceptable substitute.
 */
G2_INFINITY : G2Point
G2_INFINITY =
    { xCoeffs = zero
    , yCoeffs = zero
    }

/**
 * Generator for twisted curve over Fq2.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L44
 */
G2 : G2Point
G2 =
    { xCoeffs =
        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160
        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758
        ]
    , yCoeffs =
        [ 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
        , 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582
        ]
    }

/**
 * G2 doubled. Computed using py_ecc: `normalize(double(G2))`.
 */
G2_2P : G2Point
G2_2P =
    { xCoeffs =
        [ 3419974069068927546093595533691935972093267703063689549934039433172037728172434967174817854768758291501458544631891
        , 1586560233067062236092888871453626466803933380746149805590083683748120990227823365075019078675272292060187343402359
        ]
    , yCoeffs =
        [ 678774053046495337979740195232911687527971909891867263302465188023833943429943242788645503130663197220262587963545
        , 2374407843478705782611042739236452317510200146460567463070514850492917978226342495167066333366894448569891658583283
        ]
    }

/**
 * G2 tripled. Computed using py_ecc: `normalize(add(G2, double(G2)))`.
 */
G2_3P : G2Point
G2_3P =
    { xCoeffs =
        [ 2795155019138475430256695697248607867022196082692926850257941893956680503583886174445899854256891620515274933186478
        , 1418901263980595683832511076652430035654903023556505873032297534993731256453342997202098832403658787934376638965468
        ]
    , yCoeffs =
        [ 1713408536894110516522969272885192173669900392782465197506312048399987681703463801235485042423756235640603447122066
        , 1376945178829045108008380835987620979304438294788415956605678509674588356753313865659068546846109894276784773457993
        ]
    }

/**
 * G2 multiplied by 6. Computed using py_ecc: `normalize(multiply(G2, 6))`.
 */
G2_6P : G2Point
G2_6P =
    { xCoeffs =
        [ 3984640847924757144714972801294669751518204805083279115209564409785869025937099631985667805381121749661329977337231
        , 608866484358724393780037751128594231300217318157170134017274809385436427203952108566113171210510640978002034144337
        ]
    , yCoeffs =
        [ 3638085773299732811703058316322950283836045952826105333022656670096922749263292332009255347182392556648551235304444
        , 1315309522598195877039488735068285781409574791250756219351720987511623939545034443010380218936398442802560800338945
        ]
    }

/**
 * Determines whether or not the given point is on the G2 curve.
 * The point must satisfy the EC equation: y^^2 = x^^3 + 4
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L71
 * ```repl
 * :prove g2_is_valid_point G2
 * :prove g2_is_valid_point G2_2P
 * :prove g2_is_valid_point G2_3P
 * :prove g2_is_valid_point G2_6P
 * ```
 */
g2_is_valid_point : G2Point -> Bit
g2_is_valid_point point =
    (y~^^2) ~-~ (x~^^3) == FQ2_B2
    where
        x = point.xCoeffs
        y = point.yCoeffs

/**
 * Negate a G2 point.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls12_381/bls12_381_curve.py#L135
 * ```repl
 * :prove g2_negate G2 == G2_Negated
 * :prove g2_negate (g2_negate G2) == G2
 * ```
 */
g2_negate : G2Point -> G2Point
g2_negate point = newPoint where
    x = point.xCoeffs
    y = point.yCoeffs
    newPoint =
        { xCoeffs = x
        , yCoeffs = fqp_neg y
        }

/**
 * Double a G2 point.
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L84
 * ```repl
 * :prove g2_double G2 == G2_2P
 * :prove g2_double G2_3P == G2_6P
 * ```
 */
g2_double : G2Point -> G2Point
g2_double point = newPoint where
    x = point.xCoeffs
    y = point.yCoeffs
    m = (3 *~ (x~^^2)) ~/~ (2 *~ y)
    newX = (m~^^2) ~-~ (2 *~ x)
    newY = (m ~*~ (x ~-~ newX)) ~-~ y
    newPoint =
        { xCoeffs = newX
        , yCoeffs = newY
        }

/**
 * Add two G2 points
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L95
 * ```repl
 * :prove g2_add G2 G2 == G2_2P
 * :prove g2_add G2 G2_2P == G2_3P
 * :prove g2_add G2_3P G2_3P == G2_6P
 * ```
 */
g2_add : G2Point -> G2Point -> G2Point
g2_add p1 p2 =
    if g2_point_eq p1 G2_INFINITY then p2
    else if g2_point_eq p2 G2_INFINITY then p1
    else if (x2 == x1) && (y2 == y1) then
        g2_double p1
    else
        { xCoeffs = newX
        , yCoeffs = newY
        }
    where
    x1 = p1.xCoeffs
    y1 = p1.yCoeffs
    x2 = p2.xCoeffs
    y2 = p2.yCoeffs
    m = (y2 ~-~ y1) ~/~ (x2 ~-~ x1)
    newX = m~^^2 ~-~ x1 ~-~ x2
    newY = m ~*~ (x1 ~-~ newX) ~-~ y1

/**
 * Multiply a G2 point by a scalar
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L114
 * WARNING: This function cannot be called with a scalar equal to the `BLS_MODULUS`.
 *  Call `g2_multi` instead if `scalar == BLS_MODULUS`.
 * The optimization of running scalar multiplication on the inverse and then using the
 *  inverse of `y` is described here: https://www.mdpi.com/2227-7390/12/6/881, Section 4, second case
 * We just have to take the inverse of every `y` coefficient.
 * ```repl
 * :prove g2_multi_optimized G2 0 == g2_multi G2 0
 * :prove g2_multi_optimized G2 1 == g2_multi G2 1
 * :prove g2_multi_optimized G2 6 == g2_multi G2 6
 * :prove g2_multi_optimized G2 (`(BLS_MODULUS)-1) == g2_multi G2 (`(BLS_MODULUS)-1)
 * ```
 */
g2_multi_optimized : G2Point -> UInt256 -> G2Point
g2_multi_optimized point scalar =
    if scalar < `(BLS_MODULUS) / 2
        then g2_multi point scalar
    else
        { xCoeffs = xcoeffs
        , yCoeffs = ycoeffs
        }
    where
        inverse_scalar = `(BLS_MODULUS) - scalar
        inverse_point = g2_multi point inverse_scalar
        ycoeffs = map (\y -> fromInteger (`(Fq) - (fromZ y))) inverse_point.yCoeffs
        xcoeffs = inverse_point.xCoeffs

/**
 * Multiply a G2 point by a scalar
 * @see https://github.com/ethereum/py_ecc/blob/main/py_ecc/bls12_381/bls12_381_curve.py#L114
 * ```repl
 * :prove g2_multi G2 0 == G2_INFINITY
 * :prove g2_multi G2 1 == G2
 * :prove g2_multi G2 2 == G2_2P
 * :prove g2_multi G2 3 == G2_3P
 * :prove g2_multi G2 6 == G2_6P
 * :prove g2_multi G2_2P 3 == g2_multi G2_3P 2
 * ```
 */
g2_multi : G2Point -> UInt256 -> G2Point
g2_multi point scalar =
    if scalar == 0 then G2_INFINITY
        | scalar == 1 then point
        // If scalar is even, just double
        | scalar % 2 == 0 then g2_multi (g2_double point) (scalar / 2)
        // If scalar is odd, double and add
        else g2_add ((g2_multi (g2_double point) (scalar / 2))) point

/**
 * Helper function for testing point equality.
 * ```repl
 * :prove g2_point_eq G2 G2
 * :prove ~(g2_point_eq G2 G2_6P)
 * ```
 */
g2_point_eq : G2Point -> G2Point -> Bit
g2_point_eq p1 p2 =
    (p1.xCoeffs ~==~ p2.xCoeffs) && (p1.yCoeffs ~==~ p2.yCoeffs)

/**
 * Determine whether or not the G2 point is a member of the subgroup.
 * @see https://github.com/ethereum/py_ecc/blob/70c194edd8d1eb1457805442f0162499dbc0aac5/py_ecc/bls/g2_primitives.py#L34
 * ```repl
 * :prove (g2_subgroup_check G2_INFINITY) == False
 * :prove (g2_subgroup_check G2) == True
 * :prove (g2_subgroup_check G2_2P) == True
 * ```
 * NOTE: these repl tests are very slow (~10 seconds each for the last two).
 */
g2_subgroup_check : G2Point -> Bit
g2_subgroup_check point = G2_INFINITY != (g2_multi point `(BLS_MODULUS))

/*
 * ==========
 * Unit Tests
 * ==========
 */

/**
 * G2 negated. Computed using py_ecc: `normalize(neg(G2))`.
 */
G2_Negated : G2Point
G2_Negated =
    { xCoeffs =
        [ 352701069587466618187139116011060144890029952792775240219908644239793785735715026873347600343865175952761926303160
        , 3059144344244213709971259814753781636986470325476647558659373206291635324768958432433509563104347017837885763365758
        ]
    , yCoeffs =
        [ 2017258952934375457849735304558732518256013841723352154472679471057686924117014146018818524865681679396399932211882
        , 3074855889729334937670587859959866275799142626485414915307030157330054773488162299461738339401058098462460928340205
        ]
    }
