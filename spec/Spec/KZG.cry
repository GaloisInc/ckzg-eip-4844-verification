/**
 * The module contains functions that perform the BLS KZG operations.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#kzg
 */
module Spec::KZG where

import Common::ModArith
import Common::Utils
import Spec::BlsEC::Field
import Spec::BlsEC::G1
import Spec::BlsEC::G2
import Spec::BlsHelpers
import Spec::BlsSerde
import Spec::Permutations
import Spec::Polynomials
import Spec::TrustedSetup

/**
 * Given `y == p(z)` for a polynomial `p(x)`, compute `q(z)`: the KZG quotient polynomial evaluated at `z` for the
 *  special case where `z` is in roots of unity.
 * For more details, read https://dankradfeist.de/ethereum/2021/06/18/pcs-multiproofs.html section "Dividing
 *  when one of the points is zero". The code below computes q(x_m) for the roots of unity special case.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_quotient_eval_within_domain
 */
compute_quotient_eval_within_domain : BlsFieldElement -> Polynomial -> BlsFieldElement -> BlsFieldElement
compute_quotient_eval_within_domain z polynomial y = toIntegral result where
    result = sum [compute i | i <- [0 .. (FIELD_ELEMENTS_PER_BLOB-1)]]
    f i = (fromIntegral (polynomial@i)) - (fromIntegral y)
    omega i = fromIntegral`{BLS_MODULUS} (ROOTS_OF_UNITY_BRP@i)
    numerator i = (f i) * (omega i)
    // Adding the BLS_MODULUS doesn't affect the computation because it is modular arithmetic with that modulus
    denominator i = z' * (z' - (omega i))
    z' = fromIntegral z
    // Skip the evaluation point (z) in the sum
    compute i = if omega i != z' then div_mod (numerator i) (denominator i) else 0

/**
 * Same as for `KZGCommitment`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#custom-types
 */
type KZGProof = Bytes48

/**
 * Helper function for `compute_kzg_proof()` and `compute_blob_kzg_proof()`.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_kzg_proof_impl
 */
compute_kzg_proof_impl : Polynomial -> BlsFieldElement -> (KZGProof, BlsFieldElement)
compute_kzg_proof_impl polynomial z = (proof, y) where
    // For all x_i, compute p(x_i) - p(z)
    y = evaluate_polynomial_in_evaluation_form polynomial z
    polynomial_shifted = [(fromIntegral`{BLS_MODULUS} p) - (fromIntegral y) | p <- polynomial]
    // For all x_i, compute (x_i - z)
    denominator_poly = [(fromIntegral`{BLS_MODULUS} x) - (fromIntegral z) | x <- ROOTS_OF_UNITY_BRP]
    // Compute the quotient polynomial directly in evaluation form
    quotient_polynomial = [quotient i a b | a <- polynomial_shifted | b <- denominator_poly | i <- [0 .. FIELD_ELEMENTS_PER_BLOB-1]]
    // Handle the conditional computation of computing the quotient
    quotient : Integer -> Z BLS_MODULUS -> Z BLS_MODULUS -> BlsFieldElement
    quotient i a b =
        if b == 0 then
            // The denominator is zero hence `z` is a root of unity: we must handle it as a special case.
            // This case can only happen once at most.
            compute_quotient_eval_within_domain (ROOTS_OF_UNITY_BRP@i) polynomial y
        else
            // Compute: q(x_i) = (p(x_i) - p(z)) / (x_i - z).
            toIntegral (div_mod`{BLS_MODULUS} a b)
    proof = g1_lincomb (bit_reversal_permutation KZG_SETUP_G1_LAGRANGE) quotient_polynomial

/**
 * Compute KZG proof at point `z` for the polynomial represented by `blob`.
 * Do this by computing the quotient polynomial in evaluation form: q(x) = (p(x) - p(z)) / (x - z).
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#compute_kzg_proof
 */
compute_kzg_proof : Blob -> Bytes32 -> (KZGProof, Bytes32)
compute_kzg_proof blob z_bytes = (proof, y) where
    polynomial = blob_to_polynomial blob
    (proof, y') = compute_kzg_proof_impl polynomial (bytes_to_bls_field z_bytes)
    y = split`{BYTES_PER_FIELD_ELEMENT} y'
   
/**
 * Verify KZG proof that ``p(z) == y`` where ``p(z)`` is the polynomial represented by ``polynomial_kzg``.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#verify_kzg_proof_impl
 * Check with Galois
 * Check the index of KZG_SETUP_G2_MONOMIAL --> Should it be KZG_SETUP_G2_MONOMIAL@1 or KZG_SETUP_G2_MONOMIAL@0?
 */
verify_kzg_proof_impl : KZGCommitment -> BlsFieldElement -> BlsFieldElement -> KZGProof -> Bit
verify_kzg_proof_impl commitment z y proof = result where
    G2_multi_neg_z = g2_multi G2 (0 - (bls_field_to_uint256 z))
    X_minus_z = g2_add (bytes96_to_G2 (KZG_SETUP_G2_MONOMIAL@1)) G2_multi_neg_z
    G1_multi_neg_y = g1_multi G1 (0 - (bls_field_to_uint256 y))
    P_minus_y = g1_add (bytes48_to_G1 commitment) G1_multi_neg_y
    neg_G2 = g2_negate G2
    proof_in_G1 = bytes48_to_G1 proof
    result = pairing_check ((P_minus_y, neg_G2), (proof_in_G1, X_minus_z))

/**
 * Verify KZG proof that ``p(z) == y`` where ``p(z)`` is the polynomial represented by ``polynomial_kzg``.
 * Receives inputs as bytes.
 * @see https://github.com/ethereum/consensus-specs/blob/dev/specs/deneb/polynomial-commitments.md#verify_kzg_proof
 * Check with Galois
 * Potential issues in the Python specification: 
 *      -   KZG_SETUP_G2_MONOMIAL[1] --> KZG_SETUP_G2_MONOMIAL[0]?
 *      -   bls.multiply(bls.G2(), -z) where z is with type BLSFieldElement, i.e., uint256, but the second argument of bls.multiply is with type int.
 */
verify_kzg_proof : Bytes48 -> Bytes32 -> Bytes32 -> Bytes48 -> Bit
verify_kzg_proof commitment_bytes z_bytes y_bytes proof_bytes = 
    assert  ((length commitment_bytes) == `(BYTES_PER_COMMITMENT)) 
            error_msg_for_commitment 
            assert  ((length z_bytes) == `(BYTES_PER_FIELD_ELEMENT))
                    error_msg_for_z_bytes
                    assert  ((length y_bytes) == `(BYTES_PER_FIELD_ELEMENT)) 
                            error_msg_for_y_bytes
                            assert  ((length proof_bytes) == `(BYTES_PER_PROOF))
                                    error_msg_for_proof_bytes
                                    result where
                                        error_msg_for_commitment = "The length of commitment must be BYTES_PER_COMMITMENT"
                                        error_msg_for_z_bytes = "The length of z_bytes must be BYTES_PER_FIELD_ELEMENT"
                                        error_msg_for_y_bytes = "The length of y_bytes must be BYTES_PER_FIELD_ELEMENT"
                                        error_msg_for_proof_bytes = "The length of proof_bytes must be BYTES_PER_PROOF"
                                        commitment = bytes_to_kzg_commitment commitment_bytes
                                        z = bytes_to_bls_field z_bytes
                                        y = bytes_to_bls_field y_bytes
                                        proof = bytes_to_kzg_proof proof_bytes 
                                        result = verify_kzg_proof_impl commitment z y proof


